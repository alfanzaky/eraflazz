Langkah prioritas berdasarkan @docs/rencanaPembangunan.md#136-149:

1. Integrasi supplier nyata + worker: (selesai)
   - Implement adaptor Digiflazz (HTTP client, tanda tangan, parser).
   - Tambahkan job queue Redis dengan worker consumer, sambungkan ke `transactionUsecase` & `retryUsecase`.

2. Ledger & mutasi saldo: (selesai)
   - Buat migration + repository `mutations`, terapkan double-entry untuk debit/kredit dan refund otomatis.

3. CRUD produk & mapping supplier: (selesai)
   - Endpoint admin untuk produk dan `product_mappings`, termasuk status stok & prioritas supplier.

4. Keamanan akses:
   - JWT nyata, role-based guard, plus API Key + signature untuk jalur H2H.

5. Observability & CI dasar:
   - Prometheus metrics, struktur log trace_id, pipeline lint-test-build (mis. GitHub Actions).
----------------------------------------------------------------------------------------------------------------

## Kemajuan terbaru 1:

Audit singkat integrasi supplier & queue saat ini:

1. `domain.SupplierAdapter` sudah didefinisikan lengkap (TopUp, CheckBalance, dsb.), namun belum ada implementasi konkret seperti Digiflazz adapter maupun registrasi DI-nya @internal/domain/supplier.go#71-123. (selesai)
2. `transactionUsecase.CreateTransaction` baru menyimpan transaksi lalu mencatat TODO untuk mengantrekan ke Redis queue; belum memanggil cache repo maupun worker @internal/usecase/transaction_uc.go#38-133. (selesai)
3. `transactionUsecase.ProcessTransaction` masih memakai `simulateSupplierCall` dan belum memanggil smart routing atau adapter nyata. Refund logic juga masih bergantung pada simulasi @internal/usecase/transaction_uc.go#135-214. (selesai)
4. Redis cache repo sudah menyediakan operasi [EnqueueTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:380:0-398:1), [DequeueTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:400:0-422:1), dan [GetQueueLength](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:424:0-434:1), tapi tidak diekspos lewat interface domain maupun dipakai di usecase mana pun @internal/repository/redis/cache_repository.go#381-435. (selesai)

Langkah implementasi berikutnya untuk fokus “Integrasi Supplier Nyata + Worker”:

1. Definisikan kontrak repository/adapter di layer domain: (selesai)
   - Tambahkan interface `SupplierAdapterFactory` untuk resolve adapter berdasarkan `supplier.Code`.
   - Tambahkan `QueueRepository` (enqueue/dequeue/status) agar usecase tidak bergantung langsung ke Redis. 

2. Implementasi Digiflazz: (selesai)
   - Buat package `internal/infra/digiflazz` (atau `internal/integration/digiflazz`) berisi client HTTP, penandatanganan payload (signature `md5(username+apiKey+refId)` sesuai dokumen resmi), mapper request/response → `domain.SupplierResponse`.
   - Tambahkan konfigurasi ENV (base URL, username, api key) di `config/config.go` dan wiring di `cmd/api/main.go`.
   - Implementasi mematuhi timeout & retry dengan `context.Context`.

3. Wiring adaptor ke usecase: (selesai)
   - `transactionUsecase.ProcessTransaction` memanggil `smartRoutingUsecase` untuk menentukan supplier, lalu menggunakan `SupplierAdapter` sesuai supplier terpilih.
   - Tangani status: sukses → update transaksi & SN; gagal → lanjut ke retry (via `retryUsecase`) atau refund.

    tambahan sebelum wiring adaptor ke usecase:

    1. Menyisipkan dependency [smartRoutingUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/smart_routing_uc.go:10:0-14:1) + [SupplierAdapterFactory](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/supplier.go:99:0-102:1) ke [transactionUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:11:0-19:1).

    2. Mengubah [ProcessTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/domain/transaction.go:102:1-102:47) agar memilih supplier melalui smart routing, memanggil adaptor (Digiflazz), lalu memperbarui status sukses/gagal termasuk refund.

    3. Menautkan wiring di [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) (instansiasi smart routing UC, adaptor factory, dll.).

        1. Progress wiring adaptor ke transactionUsecase:

            Struct transactionUsecase kini membawa smartRoutingUsecase, SupplierAdapterFactory, dan retryUsecase; constructor menerima dependency baru ini @internal/usecase/transaction_uc.go#12-47.
            ProcessTransaction sekarang memakai selectSupplier (smart routing) dan executeSupplierTransaction alih-alih simulasi; supplier terpilih disimpan, lalu adaptor dipanggil, dan status sukses/gagal ditangani lengkap dengan pembaruan metrik dan refund/ retry fallback @internal/usecase/transaction_uc.go#193-406.
            Helper baru selectSupplier, executeSupplierTransaction, dan handleSupplierFailure mengurusi pemanggilan adaptor, logging, pembaruan SN/message, retry otomatis, dan refund bila semua supplier gagal @internal/usecase/transaction_uc.go#270-405.

        2. Wiring adaptor ke usecase kini lengkap:

            transactionUsecase sudah menerima smartRoutingUsecase, SupplierAdapterFactory, dan retryUsecase; ProcessTransaction memanfaatkan smart routing untuk memilih supplier, memanggil adaptor Digiflazz melalui factory, lalu mengelola status sukses/gagal, pembaruan SN/message, retry otomatis, dan refund bila perlu @internal/usecase/transaction_uc.go#12-405.
            cmd/api/main.go kini menginisialisasi seluruh dependency: product mapping repo, smart routing UC, adaptor factory + Digiflazz adapter, serta queue repo Redis, kemudian meneruskannya ke NewTransactionUsecase @cmd/api/main.go#73-102.
            
4. Job queue + worker: (selesai)
   - Extend `transactionUsecase.CreateTransaction` untuk memanggil [queueRepo.EnqueueTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:380:0-398:1).
   - Tambahkan worker (misal `internal/worker/transaction_worker.go`) yang melakukan loop [queueRepo.DequeueTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:400:0-422:1) dan memanggil `transactionUsecase.ProcessTransaction`.
   - Hubungkan worker ini di `cmd/api/main.go` atau proses terpisah (mis. `cmd/worker`).

5. Logging & error handling: (selesai)
   - Gunakan logger dengan `trace_id` per transaksi dan catat hasil supplier (status, response time) untuk dasar metrik.


## Kemajuan terbaru 2:

Konfigurasi supplier kini sudah tersedia di [Config](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:12:0-20:1):

- Menambahkan [SupplierConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:76:0-78:1) dan [DigiflazzConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:81:0-87:1), sehingga kredensial Digiflazz bisa dibaca dari ENV dan disalurkan lewat konfigurasi pusat @config/config.go#12-149.
- Ini menjadi fondasi agar adaptor Digiflazz dapat mengambil base URL, username, API key, flag testing, dan timeout tanpa hard-code.

Langkah berikutnya:
1. Tambah variabel ENV pada `.env` dan [.env.example](cci:7://file:///home/alfanro/projects/eraflazz/.env.example:0:0-0:0) untuk field baru (`DIGIFLAZZ_BASE_URL`, `DIGIFLAZZ_TESTING`, `DIGIFLAZZ_TIMEOUT` jika perlu override).
2. Implementasi client/adaptor Digiflazz yang membaca konfigurasi tersebut dan mendaftarkannya di wiring (mis. [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) / container provider).
3. Integrasikan adaptor ke `transactionUsecase` & smart routing (menggantikan [simulateSupplierCall](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/retry_uc.go:333:0-359:1)).



## Kemajuan terbaru 3:

- Konfigurasi supplier ditambahkan ke [config.Config](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:12:0-20:1), lengkap dengan struct [SupplierConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:76:0-78:1) dan [DigiflazzConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:81:0-87:1) agar kredensial bisa di-load dari ENV (@config/config.go#12-149).
- Interface [SupplierAdapterFactory](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/supplier.go:99:0-102:1) kini tersedia di domain untuk mewadahi registrasi adaptor pemasok (@internal/domain/supplier.go#90-114).
- File adaptor Digiflazz awal sudah dibuat berisi client HTTP, signature MD5, mapping response, dan helper DTO sehingga siap dihubungkan ke usecase/worker (@internal/adapter/digiflazz/adapter.go#1-344).

Lint error karena salah penulisan `nil` vs `null` pada constructor adaptor sudah diperbaiki di tempat yang sama.

Langkah selanjutnya:
1. Lengkapi adaptor Digiflazz dengan logging/error domain dan tangani kasus status lain (mis. timeout/unknown).
2. Buat registry [SupplierAdapterFactory](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/supplier.go:99:0-102:1) + wiring di [main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) untuk mendaftarkan adaptor Digiflazz menggunakan konfigurasi baru.
3. Integrasikan ke `transactionUsecase` (ganti [simulateSupplierCall](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/retry_uc.go:333:0-359:1) dengan pemilihan mapping + pemanggilan adaptor; update transaksi berdasarkan respon).
4. Setelah adaptor stabil, lanjutkan pengantrean transaksi ke Redis + worker sesuai rencana item berikutnya.


## Kemajuan terbaru 4:

- Menambahkan konfigurasi supplier ([SupplierConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:76:0-78:1), [DigiflazzConfig](cci:2://file:///home/alfanro/projects/eraflazz/config/config.go:81:0-87:1)) sehingga kredensial Digiflazz terbaca dari ENV dan siap di-inject ke komponen lain @config/config.go#12-149.

- Mendeskripsikan [SupplierAdapterFactory](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/supplier.go:99:0-102:1) di domain untuk menstandarkan registrasi adaptor supplier @internal/domain/supplier.go#90-114.

- Membuat adaptor HTTP Digiflazz lengkap dengan penandatanganan MD5, pemetaan response, serta operasi top up, saldo, status, dan price list @internal/adapter/digiflazz/adapter.go#1-344.

- Membuat registry thread-safe untuk adaptor supplier yang dapat mendaftarkan adaptor (mis. Digiflazz) lalu di-resolve berdasarkan kode @internal/adapter/factory/factory.go#1-47.

Langkah selanjutnya yang saya sarankan:
1. Wire adaptor Digiflazz ke factory dan instantiate di [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) menggunakan konfigurasi baru. (selesai)

2. Integrasikan factory ke [transactionUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:11:0-18:1) (ganti [simulateSupplierCall](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/retry_uc.go:333:0-359:1) dengan pemilihan supplier + adaptor nyata, termasuk smart routing). (selesai)

3. Setelah alur synchronous tersambung, lanjutkan implementasi job queue Redis + worker sesuai rencana.

## Kemajuan terbaru 5:

Langkah lanjut sudah dimulai untuk target job queue:

- Menambahkan [QueueRepository](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/queue.go:4:0-8:1) di domain sebagai abstraksi antrean transaksi @internal/domain/queue.go#1-8.

- Menandai [cacheRepository](cci:2://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:13:0-15:1) Redis agar memenuhi kontrak tersebut lewat type assertion @internal/repository/redis/cache_repository.go#14-23.

Berikutnya saya akan:
1. Menyuntikkan implementasi Redis ini ke [transactionUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:11:0-18:1) (konstuktor + penggunaan di [CreateTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/domain/transaction.go:101:1-101:87) dan worker).

2. Membuat worker konsumer (mis. `internal/worker/transaction_worker.go`) yang menarik ID dari antrean dan memanggil [ProcessTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/domain/transaction.go:102:1-102:47). (selesai)
3. Wire komponen baru di [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0).

## Kemajuan terbaru 6:

- [transactionUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:11:0-19:1) kini memiliki dependensi `queueRepo` dan otomatis menaruh ID transaksi ke antrean Redis setelah disimpan. Jika queue belum di-setup, muncul peringatan eksplisit agar kita tahu transaksi tidak akan diproses otomatis (@internal/usecase/transaction_uc.go#12-151).

Berikut fokus lanjutan untuk menuntaskan poin job queue:
1. Tambahkan worker konsumer (mis. `internal/worker/transaction_worker.go`) yang memanggil [queueRepo.DequeueTransaction()](cci:1://file:///home/alfanro/projects/eraflazz/internal/repository/redis/cache_repository.go:402:0-424:1) dan [transactionUC.ProcessTransaction()](cci:1://file:///home/alfanro/projects/eraflazz/internal/domain/transaction.go:102:1-102:47) di loop aman (graceful shutdown, log, metrik).

    (status: selesai)
    Worker konsumer sudah ditambahkan di internal/worker/transaction_worker.go. Komponen ini:

    Memanfaatkan QueueRepository dan TransactionUsecase, dengan konfigurasi polling sederhana (default 500 ms), serta loop yang menghormati context untuk graceful shutdown.
    Setiap tick memanggil queueRepo.DequeueTransaction(); jika ada ID, langsung menjalankan trxUC.ProcessTransaction() dan mencatat durasi/log (sukses dan gagal) @internal/worker/transaction_worker.go#1-80.

    Dependency injection queue repo sudah ditambahkan ke NewTransactionUsecase di cmd/api/main.go:

    Mengimpor repositori Redis (internal/repository/redis) dan membuat instance queueRepo := redisrepo.NewCacheRepository(rdb) @cmd/api/main.go#19-87.
    Saat memanggil usecase.NewTransactionUsecase, kini meneruskan queueRepo sebagai argumen terakhir (sementara mutationRepo masih nil sesuai TODO) @cmd/api/main.go#80-87.
    Dengan ini constructor terpenuhi dan transaksi otomatis diantrekan. Langkah berikutnya: jalankan worker (goroutine) di main.go agar antrean dikonsumsi.

2. Wire worker tersebut di [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0-0:0) (goroutine dengan context cancel) agar server langsung memproses antrean saat dijalankan.

3. Setelah worker aktif, lanjut implementasi retry + adaptor supplier nyata seperti di langkah sebelumnya

Wiring adaptor ke usecase kini lengkap:

- [transactionUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:11:0-22:1) sudah menerima [smartRoutingUsecase](cci:2://file:///home/alfanro/projects/eraflazz/internal/usecase/smart_routing_uc.go:10:0-14:1), [SupplierAdapterFactory](cci:2://file:///home/alfanro/projects/eraflazz/internal/domain/supplier.go:99:0-102:1), dan `retryUsecase`; [ProcessTransaction](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:162:0-240:1) memanfaatkan smart routing untuk memilih supplier, memanggil adaptor Digiflazz melalui factory, lalu mengelola status sukses/gagal, pembaruan SN/message, retry otomatis, dan refund bila perlu @internal/usecase/transaction_uc.go#12-405.
- [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) kini menginisialisasi seluruh dependency: product mapping repo, smart routing UC, adaptor factory + Digiflazz adapter, serta queue repo Redis, kemudian meneruskannya ke [NewTransactionUsecase](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:24:0-47:1) @cmd/api/main.go#73-102.

Langkah lanjutan yang direkomendasikan:
1. Implementasi `retryUsecase` dan `mutationRepo`, lalu injeksikan ke constructor. (selesai)
   ## Mutation repository & wiring selesai

      Membuat mutationRepository Postgres lengkap (create, query per user/reference, cek balance) sehingga memenuhi kontrak domain.MutationRepository @internal/repository/postgres/mutation_repository.go#1-109.
      transactionUsecase.createBalanceMutation kini benar-benar menyimpan mutasi lewat repo dan memberi log konfirmasi, bukan placeholder lagi @internal/usecase/transaction_uc.go#538-569.
      Constructor NewTransactionUsecase otomatis menerima instance repo ini karena wiring di cmd/api/main.go sudah menyediakan slotnya; tinggal instantiate postgres.NewMutationRepository(db) untuk mengisi TODO (bisa saya lanjutkan bila diperlukan).
   

   ## Mutation layer sudah menyatu penuh di jalur transaksi:

      Repository baru postgres.NewMutationRepository menangani CRUD mutasi sesuai kontrak domain, termasuk query historis/balance @internal/repository/postgres/mutation_repository.go#1-109.
      transactionUsecase.createBalanceMutation kini menulis mutasi ke DB lewat repo dan melog keberhasilan @internal/usecase/transaction_uc.go#538-569.
      Wiring di cmd/api/main.go telah menginisialisasi repo ini lalu meneruskan ke NewTransactionUsecase, sehingga debit/kredit saat transaksi/refund langsung tercatat @cmd/api/main.go#74-104.

   ## Retry pipeline sudah terpasang penuh di main app:

   - [cmd/api/main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) kini menginisialisasi [retryUC := usecase.NewRetryUsecase(...)](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/retry_uc.go:17:0-28:1) dan meneruskannya ke [NewTransactionUsecase](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:24:0-47:1), sehingga alur retry/failover langsung aktif @cmd/api/main.go#75-107.
   - Dengan ini [transactionUsecase.handleSupplierFailure](cci:1://file:///home/alfanro/projects/eraflazz/internal/usecase/transaction_uc.go:373:0-405:1) dapat memanfaatkan retry nyata yang akan menilai ulang supplier cadangan sebelum melakukan refund.

2. Jalankan [TransactionWorker](cci:2://file:///home/alfanro/projects/eraflazz/internal/worker/transaction_worker.go:13:0-17:1) goroutine di [main.go](cci:7://file:///home/alfanro/projects/eraflazz/cmd/api/main.go:0:0-0:0) agar antrean diproses otomatis. (selesai)

   Worker transaksi sudah dijalankan sebagai goroutine di cmd/api/main.go: setelah transactionUC dibuat, kita instantiate TransactionWorker, buat context khusus (context.WithCancel), lalu memanggil go transactionWorker.Start(workerCtx) dan memastikan workerCancel() dipanggil saat shutdown @cmd/api/main.go#93-165. Dengan begitu antrean Redis otomatis diproses selama server aktif.

3. Tambahkan logging/metrics tambahan (trace_id, status supplier) sesuai target observability. (selesai)

   Logging & metrik sudah diperkaya:

   Semua log utama di transactionUsecase sekarang menyertakan trace_id (TrxCode) dan informasi supplier yang relevan pada titik: antrean Redis, proses transaksi, pemilihan supplier, panggilan adaptor, sukses, serta kegagalan @internal/usecase/transaction_uc.go#129-411.
   executeSupplierTransaction mencatat durasi dan response_time_ms untuk membantu observability performa supplier @internal/usecase/transaction_uc.go#321-392.
   Worker akan otomatis mewarisi info ini karena ProcessTransaction sudah menulis log detail; tidak perlu perubahan tambahan di worker.
