Berikut adalah **Dokumen Perencanaan Proyek (Project Eraflazz Blueprint)** untuk membangun sistem server pulsa berbasis web (*Cloud-Based*) dengan kemampuan setara Otomax.

Dokumen ini disusun dengan standar **Software Development Life Cycle (SDLC)** untuk memastikan sistem yang dibangun handal (robust), aman, dan skalabel.

---

# PROPOSAL TEKNIS: CLOUD PULSA ENGINE (Next-Gen Otomax)

## 1. Ringkasan Proyek

* **Tujuan:** Membangun platform server pulsa terpusat berbasis web yang mampu menangani transaksi H2H (Host-to-Host) dan PPOB dengan *high concurrency* (banyak transaksi bersamaan).
* **Target Pengguna:** Pemilik Server (Admin), Reseller (Agen & Downline), dan H2H Client.
* **Kunci Keunggulan:** Kecepatan eksekusi detik, *smart routing* (mencari harga termurah otomatis), dan stabilitas anti-bengong.

---

## 2. Arsitektur Sistem (System Architecture)

Kita akan menggunakan arsitektur **Microservices** atau **Modular Monolith** agar sistem tidak berat.

### A. Tech Stack (Teknologi)

* **Backend (Core Engine):** **Golang (Go)**.
* *Alasan:* Golang digunakan oleh Gojek/Tokopedia. Sangat cepat untuk memproses ribuan request per detik dibanding PHP.

* **Database:** **PostgreSQL**.
* *Alasan:* Lebih ketat dalam menjaga konsistensi data uang dibanding MySQL biasa.

* **Caching & Queue:** **Redis**.
* *Alasan:* Menyimpan antrian transaksi agar database utama tidak jebol saat trafik tinggi.

* **Frontend (Web):** **React.js / Next.js** + Tailwind CSS.
* *Alasan:* Single Page Application (SPA), loading sangat cepat tanpa refresh halaman.

* **Bot Gateway:** **Node.js** (untuk WhatsApp, telegram dll).

### B. Diagram Alur Data

`User/Agen` -> `API Gateway` -> `Message Queue (Redis)` -> `Transaction Workers (Go)` -> `Supplier API`

---

## 3. Spesifikasi Fitur (Functional Requirements)

Ini adalah modul-modul yang harus dibangun secara bertahap:

### Modul 1: Manajemen Produk & Supplier (The Inventory)

1. **Parsing Adaptor:** Fitur untuk menerjemahkan respon dari berbagai supplier (Digiflazz, VIP, Otomax H2H lain) menjadi format standar sistem kita.
2. **Multi-Supplier Mapping:** Satu produk (misal: Telkomsel 10k) bisa disuplai oleh 5 atau lebih supplier berbeda.
3. **Smart Routing (Prioritas):** Sistem otomatis memilih supplier berdasarkan:
* Harga termurah.
* Stok tersedia.
* Sukses rate tertinggi.



### Modul 2: Transaksi & Core Engine (The Heart)

1. **Queue Management:** Jika ada 1.000 transaksi masuk detik ini, sistem akan menampung di antrian dan memproses satu per satu dengan sangat cepat (milidetik) agar server tidak hang.
2. **Retry Logic:** Jika supplier A timeout/gagal, otomatis oper ke supplier B tanpa perlu input ulang.
3. **Refund Otomatis:** Jika semua supplier gagal, saldo agen otomatis kembali detik itu juga.

### Modul 3: Keuangan (The Wallet)

1. **Double-Entry Accounting:** Mencatat setiap pergerakan saldo (Debit/Kredit) untuk mencegah selisih.
2. **Tiket Deposit:** Sistem membaca mutasi bank (BCA/BRI/Mandiri) via Internet Banking Parsing (menggunakan *headless browser* atau API pihak ketiga seperti Moota) untuk auto-input saldo.
3. **Sistem Komisi:** Perhitungan rebate/bonus untuk upline hingga kedalaman level tertentu (Unlimited level atau dibatasi).

### Modul 4: Interface & Jalur Akses

1. **Web Dashboard:** Untuk Admin memantau grafik transaksi realtime.
2. **API H2H (JSON/XML):** Dokumentasi API untuk agen yang punya server sendiri.
3. **WhatsApp Center:** Bot WA dan Telegram untuk transaksi format teks (misal: `NOMINAL.TUJUAN.PIN`).

---

## 4. Perancangan Database (Database Schema)

Berikut adalah tabel-tabel krusial yang harus ada:

| Nama Tabel | Fungsi Utama |
| --- | --- |
| `users` | Menyimpan data agen, saldo, level, markup harga, upline_id. |
| `suppliers` | Konfigurasi API supplier, saldo di supplier, status koneksi. |
| `products` | Daftar produk, kode server, kategori (Pulsa, Data, PLN). |
| `product_mappings` | Hubungan 1 Produk ke banyak Supplier (Kode Supplier, Harga Modal, Prioritas). |
| `transactions` | Log transaksi (ID, User, Produk, Tujuan, SN, Status, Profit). |
| `mutations` | Riwayat keluar masuk saldo (Wajib ada saldo awal & saldo akhir per baris). |
| `inbox/outbox` | Log pesan masuk/keluar dari WA/Telegram/SMS. |

---

## 5. Roadmap Pengembangan (Timeline)

Estimasi waktu pengerjaan jika dikerjakan oleh 1 Fullstack Developer yang berpengalaman:

* **Bulan 1: Core Backend & Database**
* Setup Server & Database.
* Coding logika transaksi dasar.
* Integrasi ke 1 Supplier H2H (Contoh: Digiflazz).


* **Bulan 2: Manajemen User & Keuangan**
* Sistem Login/Register.
* Sistem Level & Komisi.
* Sistem Tiket Deposit & Mutasi Saldo.


* **Bulan 3: Frontend Web & Routing**
* Pembuatan Web Report member area.
* Pembuatan Admin Panel.
* Implementasi logika pindah supplier otomatis.


* **Bulan 4: Gateway & Testing**
* Integrasi WhatsApp Bot.
* Stress Test (Simulasi ribuan transaksi).
* Peluncuran Beta.

---

## 5a. Status Implementasi per Modul (Feb 2026)

| Modul / Area | Status Implementasi | Catatan |
| --- | --- | --- |
| Manajemen Produk & Supplier | ⛔ Belum dikerjakan | Struct domain & repo sudah ada, namun adaptor supplier nyata, CRUD mapping, dan sinkron stok belum dibuat. |
| Transaksi & Core Engine | ⚠️ Dalam progres awal | API + handler + usecase (validasi user/product, simulasi transaksi, retry & smart routing logic) sudah ada, tapi belum tersambung ke job queue & adaptor supplier asli. |
| Keuangan (Wallet & Mutasi) | ⛔ Belum dikerjakan | Struktur Mutation sudah didefinisikan, tetapi repository, double-entry ledger, dan refund nyata belum ada. |
| Interface & Jalur Akses | ⛔ Belum dikerjakan | Belum ada dashboard Next.js, API H2H publik, maupun bot WhatsApp/Telegram. |
| Database & Migrasi | ⚠️ Sebagian | Migrasi user/supplier/transaction tersedia, tetapi tabel pendukung (mutations, product_mappings, inbox/outbox) belum dibuat. |
| Security & Observability | ⛔ Belum dikerjakan | Middleware auth masih mock, rate limiter, JWT/API key, monitoring & CI/CD belum diimplementasi. |

> **Legenda:** ✅ Selesai · ⚠️ Sebagian · ⛔ Belum mulai

## 5b. Rencana Pembangunan Berikutnya (Sprint 1–2)

1. **Integrasi Supplier Nyata & Worker**
   - Implement adaptor Digiflazz (HTTP client, tanda tangan, parser).
   - Tambah job queue Redis + worker consumer, hubungkan dengan `transactionUsecase` & `retryUsecase`.
2. **Ledger & Mutasi Saldo**
   - Buat migration + repository `mutations`, terapkan double-entry saat debit/kredit dan refund otomatis.
3. **CRUD Produk & Mapping Supplier**
   - Siapkan endpoint admin untuk produk + `product_mappings`, termasuk status stok & prioritas supplier.
4. **Keamanan Akses**
   - Implementasi JWT sesungguhnya, role-based guard, plus mekanisme API Key + signature untuk rute H2H.
5. **Fondasi Observability & CI**
   - Tambahkan Prometheus metrics, struktur log trace_id, dan pipeline GitHub Actions (lint-test-build).

---

## 6. Estimasi Infrastruktur (Biaya Server)

Untuk memulai (*Start Small*), Anda tidak butuh server fisik ratusan juta.

1. **VPS Utama (Application):** 4 vCPU, 8GB RAM (Estimasi: Rp 400.000/bulan).
2. **Managed Database:** Agar data aman dan di-backup otomatis (Estimasi: Rp 300.000/bulan).
3. **Domain & SSL:** (Rp 150.000/tahun).
4. **IP Address Khusus:** Untuk whitelist ke supplier (Rp 50.000/bulan).

---

BAGIAN II: SPESIFIKASI TEKNIS & STANDARISASI KODE
1. Filosofi Arsitektur: Clean Architecture (Modular Monolith)

Kita tidak akan langsung memecah menjadi Microservices (karena terlalu rumit di awal), tapi kita membangun Modular Monolith. Artinya, kode berada dalam satu repository tapi dipisahkan secara ketat berdasarkan modul. Jika nanti ingin dipisah jadi Microservices, tinggal "copas" folder modulnya.
4 Layer Utama:

    Entities (Domain): Berisi aturan bisnis murni. (Contoh: Saldo tidak boleh minus). Tidak boleh ada kode SQL atau HTTP di sini.

    Usecase (Service): Logika alur aplikasi. (Contoh: Alur deposit = Cek user -> Cek tiket -> Tambah saldo).

    Interface Adapters (Handler/Repo): Penerjemah data. (Contoh: Menerima JSON dari Frontend, Mengambil data dari Postgres).

    Frameworks & Drivers: Alat eksternal (Gin/Echo Framework, Redis Client, Postgres Driver).

2. Struktur Direktori Proyek (Standard Go Layout)

Struktur folder ini dirancang agar developer baru bisa langsung paham dalam 5 menit.
Plaintext

/eraflazz-core
├── /cmd                    # Entry point aplikasi (Main function)
│   └── /api                # Folder untuk menjalankan API Server
│       └── main.go
├── /config                 # Konfigurasi Environment (Database URL, Redis Host, API Key)
├── /internal               # KODE UTAMA (Private, tidak bisa diimport project lain)
│   ├── /domain             # (Layer 1) Struct & Interface definisi data
│   │   ├── user.go
│   │   ├── transaction.go
│   │   └── product.go
│   ├── /usecase            # (Layer 2) Business Logic
│   │   ├── transaction_uc.go
│   │   └── auth_uc.go
│   ├── /repository         # (Layer 3) Query Database (Postgres)
│   │   ├── postgres        # Implementasi PostgreSQL
│   │   └── redis           # Implementasi Redis Caching
│   └── /handler            # (Layer 3) HTTP Handler (API Endpoint)
│       └── http            # REST API Controller
├── /pkg                    # Library pendukung (Public, bisa dishare)
│   ├── /logger             # Standardisasi Log (Zap/Logrus)
│   ├── /utils              # Fungsi umum (Format Rupiah, Parsing No HP)
│   └── /xresponse          # Standar format respon JSON (Success/Error)
├── /migrations             # File SQL untuk membuat tabel database (Versioning)
├── /docs                   # Dokumentasi Swagger/OpenAPI
├── Dockerfile              # Konfigurasi Container
├── docker-compose.yml      # Orkestrasi Service (App + DB + Redis)
├── go.mod                  # Dependency Manager
└── Makefile                # Shortcut perintah (misal: make run, make migrate)

3. Standarisasi Database (Schema Design Best Practices)

Dalam sistem PPOB, Data Integrity adalah segalanya. Berikut aturan ketat desain database PostgreSQL:
A. Aturan Umum

    Gunakan UUID: Jangan gunakan Auto Increment Integer untuk Primary Key. UUID lebih aman untuk mencegah tebak-tebakan ID transaksi.

    Tipe Data Uang: JANGAN PERNAH gunakan FLOAT atau DOUBLE. Gunakan DECIMAL(19, 4) atau BIGINT (simpan dalam satuan perak) untuk menghindari selisih koma.

    Indexing: Wajib index pada kolom yang sering dicari: user_id, status, created_at, serial_number.
B. Detail Schema (Contoh SQL Structure)
Tabel transactions

Ini adalah tabel tersibuk. Harus efisien.
SQL

CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    trx_code VARCHAR(50) UNIQUE NOT NULL, -- Contoh: TRX-20231001-0001
    user_id UUID NOT NULL REFERENCES users(id),
    product_code VARCHAR(20) NOT NULL,
    destination_number VARCHAR(20) NOT NULL, -- Nomor HP/ID Pelanggan
    
    -- Harga & Modal (Snapshot saat transaksi terjadi)
    supplier_id UUID, -- Supplier mana yang dieksekusi
    hpp DECIMAL(19, 2) NOT NULL DEFAULT 0, -- Modal kita
    selling_price DECIMAL(19, 2) NOT NULL DEFAULT 0, -- Harga jual ke agen
    profit DECIMAL(19, 2) GENERATED ALWAYS AS (selling_price - hpp) STORED,
    
    -- Status & Respon
    status VARCHAR(20) CHECK (status IN ('PENDING', 'PROCESSING', 'SUCCESS', 'FAILED', 'REFUND')),
    serial_number VARCHAR(100), -- SN dari provider (token PLN/Ref ID)
    supplier_message TEXT, -- Pesan error dari supplier jika gagal
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index untuk mempercepat pencarian history
CREATE INDEX idx_trx_user ON transactions(user_id);
CREATE INDEX idx_trx_status ON transactions(status);
CREATE INDEX idx_trx_date ON transactions(created_at);

Tabel balances & mutations (Double Entry)

Jangan hanya update saldo user. Setiap perubahan saldo WAJIB tercatat di tabel mutasi.
SQL

CREATE TABLE mutations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    type VARCHAR(10) CHECK (type IN ('DEBIT', 'CREDIT')), -- Debit=Masuk, Credit=Keluar
    amount DECIMAL(19, 2) NOT NULL,
    balance_before DECIMAL(19, 2) NOT NULL,
    balance_after DECIMAL(19, 2) NOT NULL,
    description TEXT, -- Contoh: "Pembelian Pulsa TRX-..." atau "Deposit Tiket #..."
    reference_id UUID, -- ID Transaksi atau ID Deposit terkait
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

4. Standarisasi API (Communication Protocol)

Agar mudah dikonsumsi Frontend (Web/App) dan 3rd Party, kita gunakan standar JSON Response yang konsisten.

Format Sukses (HTTP 200):
JSON

{
  "code": 200,
  "status": "success",
  "message": "Transaction created successfully",
  "data": {
    "trx_id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "PROCESSING",
    "balance_remaining": 50000
  }
}

Format Error (HTTP 400/500):
JSON

{
  "code": 400,
  "status": "error",
  "error_code": "INSUFFICIENT_BALANCE",
  "message": "Saldo Anda tidak mencukupi untuk transaksi ini."
}

Catatan: error_code sangat penting agar Frontend bisa menerjemahkan error secara programatik.
5. Strategi Skalabilitas (Agar "Anti-Bengong")
A. Konsep Worker & Queue

Jangan memproses transaksi di thread HTTP utama.

    User klik "Beli".
    API simpan data "PENDING" ke DB -> Kirim respon "Sedang Diproses" ke User.
    API kirim Job ke Redis Queue.

    Worker (Go Routine) di background mengambil Job tersebut:

        - Cek stok supplier.
        - Tembak API Supplier.
        - Tunggu Callback/Response.
        - Update DB "SUCCESS".
        - Kirim Webhook/Notifikasi ke User.

B. Failover System

Di kode Go-nya, kita buat Logic Adaptor:
Go

// Pseudocode Logic Pindah Supplier
func ProcessTransaction(trx) {
    suppliers := GetSuppliersByPriority(trx.ProductCode) // Dapat [Digiflazz, VIP, Tokopedia]
    
    for _, supplier := range suppliers {
        err := supplier.TopUp(trx.Dest, trx.Product)
        if err == nil {
            return Success // Berhasil di supplier 1
        }
        Log("Supplier A gagal, mencoba Supplier B...")
    }
    return Failed // Semua supplier gagal
}

6. Langkah Eksekusi Pertama (Action Plan)

Untuk memulai "Coding yang Rapi", jangan langsung buka teks editor dan coding sembarangan. Lakukan langkah ini:

    Inisialisasi Project:
    Jalankan perintah ini di terminal untuk membuat struktur dasar:
    Bash

    mkdir eraflazz-core
    cd eraflazz-core
    go mod init github.com/username/eraflazz-core
    # Buat folder struktur
    mkdir -p cmd/api internal/domain internal/usecase internal/repository internal/handler/http config pkg/utils

    Setup Docker Compose:
    Siapkan file docker-compose.yml untuk menjalankan PostgreSQL dan Redis secara lokal tanpa menginstall manual di laptop.

    Definisi Domain:
    Mulai coding dari folder /internal/domain. Tentukan struct User dan Transaction dulu sebelum memikirkan database.

## Catatan

---

### 7. Standarisasi Penulisan Kode & Kolaborasi

1. **Linting & Formatting:** Wajib menjalankan `golangci-lint` sebelum push. Untuk frontend gunakan `eslint` + `prettier`. Atur hook pre-commit agar pelanggaran langsung ditolak.
2. **Konvensi Commit:** Ikuti pola *Conventional Commits* (`feat:`, `fix:`, `chore:`) untuk memudahkan auto-changelog dan penelusuran git.
3. **Code Review:** Setiap PR minimal direview 1 rekan. Reviewer fokus pada kepatuhan arsitektur (Clean Architecture), keamanan, dan kover test.

### 8. Detail Endpoint & Otentikasi API

Tambahkan contoh endpoint berikut pada dokumentasi:

| Endpoint | Deskripsi | Auth | Rate Limit |
| --- | --- | --- | --- |
| `POST /api/v1/transactions` | Membuat transaksi baru | JWT atau API Key | 60 req/menit/user |
| `GET /api/v1/balance` | Mengecek saldo agen | JWT | 120 req/menit/user |
| `POST /api/v1/callbacks/supplier` | Endpoint callback status supplier | Signature HMAC | Per supplier |

Otentikasi standar:

* **JWT** untuk akses dashboard/web.
* **API Key + Signature** untuk mitra H2H. Setiap request wajib menyertakan `X-Api-Key` dan header `X-Signature` (HMAC SHA256 dari payload + timestamp).
* **Rate Limiter** diletakkan di API Gateway (Redis leaky bucket) untuk menghindari spam.

### 9. Manajemen Konfigurasi & Secret

1. **Hierarki ENV:** `.env` lokal -> `.env.staging` -> `.env.production`. Jangan commit nilai sensitif.
2. **Secret Storage:** Gunakan Vault/Secret Manager (contoh: Hashicorp Vault atau AWS Secrets Manager) untuk API key supplier, token bank, dsb.
3. **Rotasi Berkala:** Minimal 90 hari sekali untuk API key kritikal. Dokumentasikan prosedur rotasi & verifikasi akses.

---

# BAGIAN III: OPERASIONAL & KEAMANAN

### 1. Arsitektur Deployment

* **Environment:** Dev (local Docker), Staging (mirror production), Production.
* **Topology:** Load Balancer -> API Gateway -> App Server (Go) -> Postgres Managed -> Redis Cluster -> Object Storage (log/archive).
* **High Availability:** Gunakan minimal 2 instance app server (auto-restart via systemd/k8s) dan standby replica Postgres.

### 2. Strategi CI/CD

1. **Pipeline Step:** Lint -> Unit Test -> Build -> Integration Test -> Security Scan -> Deploy.
2. **Staging Gate:** Deployment ke production hanya boleh setelah staging lulus UAT checklist dan QA sign-off.
3. **Rollback Plan:** Simpan artefak build minimal 5 versi terakhir. Deploy menggunakan strategi blue/green atau rolling dengan health check.

### 3. Observability & Monitoring

* **Logging:** Gunakan struktur JSON dengan korelasi ID (trace_id). Centralized logging via Loki/ELK.
* **Metrics:** Expose Prometheus metrics (latency transaksi, success rate supplier, queue depth).
* **Tracing:** Aktifkan OpenTelemetry untuk melacak span antar service (API -> Worker -> Supplier).
* **Alerting:** Threshold utama: error rate >2%, saldo supplier < ambang, waktu proses >5 detik. Kirim notifikasi ke Slack/Telegram NOC.

### 4. Kebijakan Keamanan

1. **Kontrol Akses:** Terapkan RBAC. Admin, Finance, Support memiliki scope berbeda.
2. **Audit Log:** Catat semua aksi kritikal (login admin, perubahan harga, penambahan saldo manual).
3. **Enkripsi:** TLS 1.2+ untuk seluruh trafik. Data sensitif (token bank, API key) dienkripsi at-rest menggunakan KMS.
4. **Rotasi Credential:** Otomatiskan rotasi password DB, API key supplier, dan token bot.

---

# BAGIAN IV: KUALITAS & RELIABILITAS

### 1. Strategi Quality Assurance

* **Unit Test:** Target coverage minimal 70% pada domain & usecase.
* **Integration Test:** Gunakan mock supplier (sandbox) untuk mensimulasikan berbagai status (Sukses/Timeout/Error).
* **UAT Checklist:** Validasi flow end-to-end (deposit, beli produk, refund, komisi) sebelum rilis.

### 2. Performance & Resilience Testing

1. **Target TPS:** Minimal 200 TPS stabil dengan latency < 1 detik pada worker utama.
2. **Alat Uji:** K6 atau Locust untuk API; Vegeta untuk stress worker.
3. **Chaos Test:** Simulasikan supplier down, Redis penuh, atau worker crash untuk menguji retry dan failover.

### 3. Incident Response & SLI/SLA

* **SLA:** 99.5% uptime bulanan, transaksi diproses < 5 detik rata-rata.
* **SLI:** Success rate transaksi, waktu antrian, saldo supplier tersedia.
* **SOP Insiden:** Status page, eskalasi 3 level (On-call -> Lead -> CTO), postmortem 24 jam setelah insiden kritis.

---

# BAGIAN V: MANAJEMEN PRODUK & RISIKO

### 1. Backlog Prioritas

* **MVP (Release 1):** Core transaction engine, 1 supplier integrasi, dashboard admin dasar, deposit manual.
* **Fase 2:** Automation deposit, komisi berjenjang, API publik.
* **Fase 3:** Bot WA/Telegram, smart routing multi-supplier penuh, analitik realtime.
* Setiap backlog item wajib punya *Definition of Done* (kode + test + dokumen + monitoring siap).

### 2. Matriks Risiko

| Risiko | Dampak | Mitigasi | Owner |
| --- | --- | --- | --- |
| Supplier utama downtime | Tinggi | Multi-supplier + health check berkala | Tim Integrasi |
| Kebocoran API key | Tinggi | Secret manager + rotasi otomatis + audit | Tim Keamanan |
| Antrian transaksi menumpuk | Sedang | Autoscale worker + alert queue depth | Tim Backend |
| Fraud deposit | Tinggi | Verifikasi mutasi multi-layer + anomaly detection | Tim Finance |

### 3. Lampiran & Referensi

1. **Glosarium:** Pulsa H2H, PPOB, SN, Sukses Rate, Smart Routing, Double Entry.
2. **Referensi:** Dokumen API supplier, standar PCI DSS (untuk inspirasi keamanan), referensi arsitektur Go Cloud Native.
3. **Tooling Disetujui:** Terraform untuk infra, Grafana untuk dashboard, GitHub Actions untuk CI/CD, Sentry untuk error tracking.



